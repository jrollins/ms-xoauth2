#!/usr/bin/env python3

# https://datatracker.ietf.org/doc/html/rfc6749

# https://learn.microsoft.com/en-us/entra/msal/python/
# https://learn.microsoft.com/en-us/entra/identity-platform/quickstart-register-app

# https://requests-oauthlib.readthedocs.io/en/latest/oauth2_workflow.html

# https://learn.microsoft.com/en-us/entra/identity-platform/v2-oauth2-auth-code-flow
# https://learn.microsoft.com/en-us/exchange/client-developer/legacy-protocols/how-to-authenticate-an-imap-pop-smtp-application-by-using-oauth
# https://www.imss.caltech.edu/services/email-calendar-messaging/email-configuration-guides/evolution
# https://www.imss.caltech.edu/services/email-calendar-messaging/email-configuration-guides/thunderbird

import os
import sys
import time
import json
import shutil
import logging
import argparse
import subprocess
import configparser
import webbrowser
from datetime import datetime
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import urlparse, parse_qs

import requests
from requests_oauthlib import OAuth2Session

from appdirs import user_config_dir, user_cache_dir

logger = logging.getLogger(__name__)

##################################################

MS_AUTH_URL = "https://login.microsoftonline.com/{tenant}/oauth2/v2.0/authorize"
MS_TOKEN_URL = "https://login.microsoftonline.com/{tenant}/oauth2/v2.0/token"
MS_DEVICE_CODE_URL = "https://login.microsoftonline.com/{tenant}/oauth2/v2.0/devicecode"
MS_REDIRECT_URI_NATIVECLIENT = "https://login.microsoftonline.com/common/oauth2/nativeclient"
MS_SCOPES = ["https://outlook.office.com/SMTP.Send", "offline_access"]

DEFAULT_CONFIG_PATH = os.path.join(user_config_dir(), 'ms-xoauth2', 'config')
CACHE_DIR = os.path.join(user_cache_dir(), 'ms-xoauth2')

##################################################
# GUI Dialog Functions
##################################################

def find_dialog_tool():
    """Find an available dialog tool (zenity or gxmessage)."""
    for tool in ['zenity', 'gxmessage']:
        if shutil.which(tool):
            return tool
    return None


def show_info_dialog(title, message):
    """Display an informational dialog to the user."""
    tool = find_dialog_tool()
    logger.debug(f"showing info dialog via {tool}: {title}")

    if tool == 'zenity':
        subprocess.run([
            'zenity', '--info',
            '--title', title,
            '--text', message,
            '--width', '400',
        ])
    elif tool == 'gxmessage':
        subprocess.run([
            'gxmessage', '-center',
            '-title', title,
            message,
        ])
    else:
        # Fallback to stderr
        print(f"\n{title}\n{message}\n", file=sys.stderr)


def show_entry_dialog(title, prompt, default=''):
    """Display a dialog prompting for text input. Returns the entered text."""
    tool = find_dialog_tool()
    logger.debug(f"showing entry dialog via {tool}: {title}")

    if tool == 'zenity':
        result = subprocess.run([
            'zenity', '--entry',
            '--title', title,
            '--text', prompt,
            '--entry-text', default,
            '--width', '500',
        ], capture_output=True, text=True)
        if result.returncode == 0:
            return result.stdout.strip()
        return None
    elif tool == 'gxmessage':
        result = subprocess.run([
            'gxmessage', '-center',
            '-title', title,
            '-entrytext', default,
            prompt,
        ], capture_output=True, text=True)
        if result.returncode == 0:
            return result.stdout.strip()
        return None
    else:
        # Fallback to terminal input
        return input(f"{prompt}: ")


def show_code_dialog(verification_uri, user_code, expires_minutes):
    """Display dialog with device code and open browser to verification URL."""
    tool = find_dialog_tool()
    logger.debug(f"showing code dialog via {tool}")

    # Open browser to verification URI
    webbrowser.open(verification_uri)

    message = (
        f"A browser has been opened to:\n"
        f"{verification_uri}\n\n"
        f"Enter this code to authenticate:\n\n"
        f"    {user_code}\n\n"
        f"This code expires in {expires_minutes} minutes.\n\n"
        f"Click OK after you have completed authentication."
    )

    if tool == 'zenity':
        subprocess.run([
            'zenity', '--info',
            '--title', 'Microsoft Authentication',
            '--text', message,
            '--width', '450',
        ])
    elif tool == 'gxmessage':
        subprocess.run([
            'gxmessage', '-center',
            '-title', 'Microsoft Authentication',
            message,
        ])
    else:
        print(f"\n{message}\n", file=sys.stderr)
        input("Press Enter after completing authentication...")

##################################################
# device redirect method
##################################################

def request_device_code(tenant, client_id, scopes):
    """Request a device code for the device code flow.

    Returns dict with device_code, user_code, verification_uri, etc.
    """
    device_code_url = MS_DEVICE_CODE_URL.format(tenant=tenant)
    scope_str = " ".join(scopes)

    response = requests.post(device_code_url, data={
        'client_id': client_id,
        'scope': scope_str,
    })

    if response.status_code != 200:
        raise ValueError(f"device code request failed: {response.text}")

    return response.json()


def poll_for_token(tenant, client_id, device_code, interval=5, timeout=900):
    """Poll the token endpoint until user completes authentication.

    Args:
        tenant: Azure AD tenant ID
        client_id: Application client ID
        device_code: Device code from request_device_code()
        interval: Polling interval in seconds (from device code response)
        timeout: Maximum time to wait in seconds

    Returns:
        Token dict with access_token, refresh_token, etc.
    """
    token_url = MS_TOKEN_URL.format(tenant=tenant)
    start_time = time.time()

    while time.time() - start_time < timeout:
        response = requests.post(token_url, data={
            'grant_type': 'urn:ietf:params:oauth:grant-type:device_code',
            'client_id': client_id,
            'device_code': device_code,
        })

        data = response.json()

        if response.status_code == 200:
            # Success - add expires_at for compatibility with existing code
            if 'expires_in' in data and 'expires_at' not in data:
                data['expires_at'] = time.time() + data['expires_in']
            return data

        error = data.get('error')
        if error == 'authorization_pending':
            # User hasn't completed auth yet, keep polling
            logger.debug("authorization pending, polling...")
            time.sleep(interval)
        elif error == 'slow_down':
            # Server wants us to slow down
            interval += 5
            logger.debug(f"slowing down, new interval: {interval}s")
            time.sleep(interval)
        elif error == 'expired_token':
            raise ValueError("device code expired - user did not complete authentication in time")
        elif error == 'access_denied':
            raise ValueError("user denied the authorization request")
        else:
            raise ValueError(f"token request failed: {data.get('error_description', error)}")

    raise ValueError("timeout waiting for user to complete authentication")


def launch_device_code_dialog(verification_uri, user_code, expires_minutes):
    """Launch a non-blocking dialog showing the device code and open browser.

    Returns the Popen process so it can be terminated later.
    """
    tool = find_dialog_tool()
    logger.debug(f"launching device code dialog via {tool}")

    # Open browser to verification URI
    webbrowser.open(verification_uri)

    message = (
        f"A browser has been opened to:\n"
        f"{verification_uri}\n\n"
        f"Enter this code to authenticate:\n\n"
        f"    {user_code}\n\n"
        f"This code expires in {expires_minutes} minutes.\n"
        f"This dialog will close automatically when complete."
    )

    if tool == 'zenity':
        # Use --info with --no-wrap for better formatting
        proc = subprocess.Popen([
            'zenity', '--info',
            '--title', 'Microsoft Authentication Required',
            '--text', message,
            '--width', '450',
            '--no-wrap',
        ])
        return proc
    elif tool == 'gxmessage':
        proc = subprocess.Popen([
            'gxmessage', '-center',
            '-title', 'Microsoft Authentication Required',
            '-buttons', 'Waiting...',
            message,
        ])
        return proc
    else:
        # No dialog tool - print to stderr
        print(f"\n{message}\n", file=sys.stderr)
        return None


def get_token_device_code(tenant, client_id, scopes):
    """Obtain a token using the device code flow.

    Opens browser and shows dialog with code, then polls for completion.
    """
    logger.debug("initiating device code flow...")

    device_code_response = request_device_code(tenant, client_id, scopes)

    user_code = device_code_response['user_code']
    verification_uri = device_code_response['verification_uri']
    device_code = device_code_response['device_code']
    interval = device_code_response.get('interval', 5)
    expires_in = device_code_response.get('expires_in', 900)

    # Launch non-blocking dialog and open browser
    dialog_proc = launch_device_code_dialog(
        verification_uri, user_code, expires_in // 60
    )

    try:
        token = poll_for_token(tenant, client_id, device_code, interval=interval, timeout=expires_in)
    finally:
        # Close the dialog if still open
        if dialog_proc and dialog_proc.poll() is None:
            dialog_proc.terminate()

    # Show success notification
    show_info_dialog("Authentication Complete", "Microsoft authentication was successful!")

    return token

##################################################
# localhost redirect method
##################################################

class OAuthCallbackHandler(BaseHTTPRequestHandler):
    """HTTP request handler to capture OAuth callback."""

    def do_GET(self):
        """Handle the OAuth callback GET request."""
        self.server.callback_url = f"http://localhost:{self.server.server_port}{self.path}"

        # Parse the query parameters
        query = parse_qs(urlparse(self.path).query)

        if 'code' in query:
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            self.wfile.write(b"""
                <html><body>
                <h1>Authorization successful!</h1>
                <p>You can close this window and return to the application.</p>
                </body></html>
            """)
        elif 'error' in query:
            error = query.get('error', ['unknown'])[0]
            error_desc = query.get('error_description', ['No description'])[0]
            self.send_response(400)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            self.wfile.write(f"""
                <html><body>
                <h1>Authorization failed</h1>
                <p>Error: {error}</p>
                <p>Description: {error_desc}</p>
                </body></html>
            """.encode())
        else:
            self.send_response(400)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            self.wfile.write(b"""
                <html><body>
                <h1>Invalid callback</h1>
                <p>No authorization code received.</p>
                </body></html>
            """)

    def log_message(self, format, *args):
        """Suppress default HTTP server logging."""
        logger.debug(f"HTTP: {format % args}")


def start_local_server():
    """Start a local HTTP server on a free port to receive the OAuth callback.

    Binds to port 0 to let the OS assign an available high-numbered port.
    Returns the server instance. The callback URL will be stored in
    server.callback_url after a request is received.
    """
    server = HTTPServer(("localhost", 0), OAuthCallbackHandler)
    server.callback_url = None
    server.timeout = 300  # 5 minute timeout
    port = server.server_address[1]
    address = f"http://localhost:{port}/"
    logger.debug(f"started local HTTP server on port {port}")
    return server, address


def user_resolve_auth_url_localhost(auth_url, client_id, scopes):
    """Start local server, open browser, and capture OAuth callback.

    Starts a local HTTP server on a free port, constructs the authorization
    URL with the correct redirect URI, opens the browser, and waits for
    the callback.

    Returns tuple of (authorization_redirect_url, redirect_uri) so the caller
    can use the same redirect_uri for token exchange.
    """
    # Start server on a free port
    server, redirect_uri = start_local_server()

    # Create OAuth session with the dynamic redirect URI
    os.environ['OAUTHLIB_RELAX_TOKEN_SCOPE'] = 'True'
    client = OAuth2Session(
        client_id,
        scope=scopes,
        redirect_uri=redirect_uri,
    )

    authorization_url, state = client.authorization_url(auth_url)
    logger.debug(f"state: {state}")
    logger.debug(f"opening browser to: {authorization_url}")

    # Open browser to authorization URL
    webbrowser.open(authorization_url)

    print(f"Opened browser for authorization. Waiting for callback on port {port}...", file=sys.stderr)

    # Wait for the callback
    server.handle_request()

    if not server.callback_url:
        raise ValueError("no callback received from OAuth flow")

    logger.debug(f"received callback: {server.callback_url}")
    return server.callback_url, redirect_uri

##################################################
# embeded redirect method
##################################################

def user_resolve_auth_url_embedded(authorization_url, redirect_uri):
    """Open embedded browser window and capture OAuth redirect automatically.

    Uses pywebview to display an embedded browser that monitors URL changes
    and captures the authorization code when the redirect occurs.
    """
    try:
        import webview
    except ImportError:
        raise ImportError(
            "pywebview is required for embedded browser authentication. "
            "Install it with: pip install pywebview"
        )

    redirect_url = None
    error = None

    def on_loaded():
        """Check if we've been redirected to the callback URL."""
        nonlocal redirect_url
        current_url = window.get_current_url()
        logger.debug(f"webview loaded: {current_url}")
        if current_url and current_url.startswith(redirect_uri):
            redirect_url = current_url
            window.destroy()

    def on_closing():
        """Handle window close without completing auth."""
        nonlocal error
        if not redirect_url:
            error = "Authentication window closed before completion"
        return True

    logger.debug(f"opening embedded browser to: {authorization_url}")

    window = webview.create_window(
        'Microsoft Authentication',
        authorization_url,
        width=500,
        height=700,
    )
    window.events.loaded += on_loaded
    window.events.closing += on_closing

    # Start the webview (blocks until window is closed)
    webview.start()

    if error:
        raise ValueError(error)

    if not redirect_url:
        raise ValueError("no redirect URL captured from embedded browser")

    logger.debug(f"captured redirect: {redirect_url}")
    return redirect_url

##################################################
# manual redirect method
##################################################

def user_resolve_auth_url_manual(authorization_url):
    """Open browser and prompt user to paste the redirect URL via dialog."""
    logger.debug(f"opening browser to: {authorization_url}")

    # Open browser to authorization URL
    webbrowser.open(authorization_url)

    prompt = (
        "A browser has been opened for Microsoft authentication.\n\n"
        "After signing in, you will be redirected to a page.\n"
        "Copy the FULL URL from your browser's address bar\n"
        "and paste it below:"
    )

    auth_redirect = show_entry_dialog(
        "Microsoft Authentication",
        prompt,
    )

    if not auth_redirect:
        raise ValueError("no redirect URI provided.")
    return auth_redirect

##################################################

def load_token(token_path):
    with open(token_path) as f:
        token = json.load(f)
    # update the expires_in field
    # if 'acquired' in token:
    #     expires = token['acquired'] + token['expires_in']
    #     expires_in = expires - time.time()
    #     token['expires_in'] = expires_in
    return token


def write_token(token, token_path, acquired=None):
    os.makedirs(
        os.path.dirname(token_path),
        mode=0o700, exist_ok=True,
    )
    # if acquired:
    #     token['acquired'] = acquired
    with open(token_path, 'w') as f:
        json.dump(token, f)
    logger.debug(f"token written: {token_path}")
    logger.debug(f"token: {token}")


def log_token(token):
    logfunc = logger.debug
    scope = token['scope']
    expires = datetime.fromtimestamp(token['expires_at'])
    expired = time.time() >= token['expires_at']
    logfunc(f"token scope: {scope}")
    logfunc(f"token expiration: {expires}")
    logfunc(f"token expired: {expired}")
    return expired

##################################################

def get_token(account, auth_method='localhost'):
    """Get an OAuth token for the account, using cached token if valid.

    Args:
        account: Account dict with name, tenant, client_id
        auth_method: Authentication method - 'localhost', 'device', or 'manual'
    """
    name = account['name']
    tenant = account['tenant']
    client_id = account['client_id']

    token_path = os.path.join(CACHE_DIR, 'tokens', f'{name}.json')
    try:
        token = load_token(token_path)
        logger.debug(f"existing token retrieved from {token_path}")
    except FileNotFoundError:
        logger.debug("no existing token found")
        token = None

    if token:
        expired = log_token(token)
        if not expired:
            return token

    token_url = MS_TOKEN_URL.format(tenant=tenant)

    # Try to refresh existing token first (works for all auth methods)
    if token:
        logger.debug("refreshing token...")
        try:
            response = requests.post(token_url, data={
                'grant_type': 'refresh_token',
                'client_id': client_id,
                'refresh_token': token.get('refresh_token'),
                'scope': ' '.join(MS_SCOPES),
            })
            if response.status_code == 200:
                token = response.json()
                if 'expires_in' in token and 'expires_at' not in token:
                    token['expires_at'] = time.time() + token['expires_in']
                write_token(token, token_path)
                log_token(token)
                return token
            else:
                logger.error(f"refresh failed: {response.text}")
        except Exception as e:
            logger.error(e)

    logger.debug(f"retrieving new token via {auth_method} method...")

    # Device code flow - doesn't use redirect URI
    if auth_method == 'device':
        token = get_token_device_code(tenant, client_id, MS_SCOPES)
        write_token(token, token_path)
        return token

    # Authorization code flow (embedded, localhost, or manual)
    auth_url = MS_AUTH_URL.format(tenant=tenant)

    # Localhost method handles authorization internally (needs dynamic port)
    if auth_method == 'localhost':
        authorization_redirect, redirect_uri = user_resolve_auth_url_localhost(
            auth_url, client_id, MS_SCOPES
        )

    else:
        # Other methods use nativeclient URI
        redirect_uri = MS_REDIRECT_URI_NATIVECLIENT

        os.environ['OAUTHLIB_RELAX_TOKEN_SCOPE'] = 'True'
        client = OAuth2Session(
            client_id,
            scope=MS_SCOPES,
            redirect_uri=redirect_uri,
        )

        authorization_url, state = client.authorization_url(auth_url)
        logger.debug(f"state: {state}")
        logger.debug(f"authorization url: {authorization_url}")

        if auth_method == 'embedded':
            authorization_redirect = user_resolve_auth_url_embedded(authorization_url, redirect_uri)
        else:
            authorization_redirect = user_resolve_auth_url_manual(authorization_url)

    logger.debug(f"redirect url: {authorization_redirect}")

    # Create OAuth session for token exchange (needed for localhost which doesn't create one above)
    os.environ['OAUTHLIB_RELAX_TOKEN_SCOPE'] = 'True'
    client = OAuth2Session(
        client_id,
        scope=MS_SCOPES,
        redirect_uri=redirect_uri,
    )

    logger.debug("token fetch...")
    token = client.fetch_token(
        token_url,
        authorization_response=authorization_redirect,
        include_client_id=True,
    )
    acquired = time.time()
    expires = datetime.fromtimestamp(token['expires_at'])
    logger.debug(f"new token retrieved (expires: {expires})")

    write_token(token, token_path, acquired=acquired)

    return token

##################################################

def load_config(config_path):
    config = configparser.ConfigParser()
    config.read(config_path)
    return config


def get_account(config, account='default'):
    if account == 'default':
        account = config['default']['account']
    logger.debug(f"account: {account}")
    return dict(config[account], name=account)

##################################################

parser = argparse.ArgumentParser(
    description="retrieve, manage, and return MS xoauth2 access token",
    formatter_class=argparse.ArgumentDefaultsHelpFormatter,
)
parser.add_argument(
    '--config', '-c', default=DEFAULT_CONFIG_PATH,
    help="path to config file tenant and client_id strings",
)
parser.add_argument(
    '--account', '-a', default='default',
    help="config account to use",
)
parser.add_argument(
    '--method', '-m', default='embedded',
    choices=['embedded', 'localhost', 'device', 'manual'],
    help="authentication method: "
         "'embedded' (embedded browser window), "
         "'localhost' (browser redirect to local server), "
         "'device' (enter code at microsoft.com/devicelogin), "
         "'manual' (paste redirect URL)",
)


def main():
    logger.setLevel(os.getenv('LOG_LEVEL', 'DEBUG').upper())
    handler = logging.StreamHandler()
    handler.setFormatter(
        logging.Formatter(
            # '%(asctime)s %(message)s'
            '%(message)s'
        )
    )
    logger.addHandler(handler)

    args = parser.parse_args()

    config = load_config(args.config)

    account = get_account(config, args.account)

    token = get_token(account, auth_method=args.method)

    print(token['access_token'])


if __name__ == '__main__':
    main()
