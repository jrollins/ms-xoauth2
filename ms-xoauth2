#!/usr/bin/env python3

# https://datatracker.ietf.org/doc/html/rfc6749

# https://learn.microsoft.com/en-us/entra/msal/python/
# https://learn.microsoft.com/en-us/entra/identity-platform/quickstart-register-app

# https://requests-oauthlib.readthedocs.io/en/latest/oauth2_workflow.html

# https://learn.microsoft.com/en-us/entra/identity-platform/v2-oauth2-auth-code-flow
# https://learn.microsoft.com/en-us/exchange/client-developer/legacy-protocols/how-to-authenticate-an-imap-pop-smtp-application-by-using-oauth
# https://www.imss.caltech.edu/services/email-calendar-messaging/email-configuration-guides/evolution
# https://www.imss.caltech.edu/services/email-calendar-messaging/email-configuration-guides/thunderbird

import os
import sys
import time
import json
import logging
import argparse
import configparser
import webbrowser
from datetime import datetime
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import urlparse, parse_qs

from requests_oauthlib import OAuth2Session

# from xdg_base_dirs import xdg_config_home, xdg_cache_home
from appdirs import user_config_dir, user_cache_dir

logger = logging.getLogger(__name__)

##################################################

class OAuthCallbackHandler(BaseHTTPRequestHandler):
    """HTTP request handler to capture OAuth callback."""

    def do_GET(self):
        """Handle the OAuth callback GET request."""
        self.server.callback_url = f"http://localhost:{self.server.server_port}{self.path}"

        # Parse the query parameters
        query = parse_qs(urlparse(self.path).query)

        if 'code' in query:
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            self.wfile.write(b"""
                <html><body>
                <h1>Authorization successful!</h1>
                <p>You can close this window and return to the application.</p>
                </body></html>
            """)
        elif 'error' in query:
            error = query.get('error', ['unknown'])[0]
            error_desc = query.get('error_description', ['No description'])[0]
            self.send_response(400)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            self.wfile.write(f"""
                <html><body>
                <h1>Authorization failed</h1>
                <p>Error: {error}</p>
                <p>Description: {error_desc}</p>
                </body></html>
            """.encode())
        else:
            self.send_response(400)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            self.wfile.write(b"""
                <html><body>
                <h1>Invalid callback</h1>
                <p>No authorization code received.</p>
                </body></html>
            """)

    def log_message(self, format, *args):
        """Suppress default HTTP server logging."""
        logger.debug(f"HTTP: {format % args}")


def start_local_server(port=8400):
    """Start a local HTTP server to receive the OAuth callback.

    Returns the server instance. The callback URL will be stored in
    server.callback_url after a request is received.
    """
    server = HTTPServer(('localhost', port), OAuthCallbackHandler)
    server.callback_url = None
    server.timeout = 300  # 5 minute timeout
    return server


def get_localhost_redirect_uri(port=8400):
    """Return the localhost redirect URI for the given port."""
    return f"http://localhost:{port}/"

##################################################

MS_AUTH_URL = "https://login.microsoftonline.com/{tenant}/oauth2/v2.0/authorize"
MS_TOKEN_URL = "https://login.microsoftonline.com/{tenant}/oauth2/v2.0/token"
MS_SCOPES = ["https://outlook.office.com/SMTP.Send", "offline_access"]

LOCALHOST_PORT = 8400

DEFAULT_CONFIG_PATH = os.path.join(user_config_dir(), 'ms-xoauth2', 'config')
CACHE_DIR = os.path.join(user_cache_dir(), 'ms-xoauth2')

##################################################

def load_config(config_path):
    config = configparser.ConfigParser()
    config.read(config_path)
    return config


def get_account(config, account='default'):
    if account == 'default':
        account = config['default']['account']
    logger.debug(f"account: {account}")
    return dict(config[account], name=account)


def user_resolve_auth_url_manual(authorization_url):
    """Prompt user to manually visit URL and paste the redirect (legacy fallback)."""
    auth_redirect = input(f"""
Visit link in a web browser, then paste the resulting URL:

{authorization_url}

Resulting URL: """)
    print('', file=sys.stderr)
    if not auth_redirect:
        raise ValueError("no redirect URI provided.")
    return auth_redirect


def user_resolve_auth_url_localhost(authorization_url, port=LOCALHOST_PORT):
    """Open browser and capture OAuth callback via local HTTP server."""
    server = start_local_server(port)

    logger.debug(f"started local server on port {port}")
    logger.debug(f"opening browser to: {authorization_url}")

    # Open browser to authorization URL
    webbrowser.open(authorization_url)

    print(f"Opened browser for authorization. Waiting for callback...", file=sys.stderr)

    # Wait for the callback
    server.handle_request()

    if not server.callback_url:
        raise ValueError("no callback received from OAuth flow")

    logger.debug(f"received callback: {server.callback_url}")
    return server.callback_url

##################################################

def load_token(token_path):
    with open(token_path) as f:
        token = json.load(f)
    # update the expires_in field
    # if 'acquired' in token:
    #     expires = token['acquired'] + token['expires_in']
    #     expires_in = expires - time.time()
    #     token['expires_in'] = expires_in
    return token


def write_token(token, token_path, acquired=None):
    os.makedirs(
        os.path.dirname(token_path),
        mode=0o700, exist_ok=True,
    )
    # if acquired:
    #     token['acquired'] = acquired
    with open(token_path, 'w') as f:
        json.dump(token, f)
    logger.debug(f"token written: {token_path}")
    logger.debug(f"token: {token}")


def log_token(token):
    logfunc = logger.debug
    scope = token['scope']
    expires = datetime.fromtimestamp(token['expires_at'])
    expired = time.time() >= token['expires_at']
    logfunc(f"token scope: {scope}")
    logfunc(f"token expiration: {expires}")
    logfunc(f"token expired: {expired}")
    return expired

##################################################

def get_token(account, use_localhost=True):
    name = account['name']
    tenant = account['tenant']
    client_id = account['client_id']

    token_path = os.path.join(CACHE_DIR, 'tokens', f'{name}.json')
    try:
        token = load_token(token_path)
        logger.debug(f"existing token retrieved from {token_path}")
    except FileNotFoundError:
        logger.debug("no existing token found")
        token = None

    if token:
        expired = log_token(token)
        if not expired:
            return token

    auth_url = MS_AUTH_URL.format(tenant=tenant)
    token_url = MS_TOKEN_URL.format(tenant=tenant)

    # Use localhost redirect for new authorization flow
    redirect_uri = get_localhost_redirect_uri(LOCALHOST_PORT) if use_localhost else None

    def token_updater(token):
        write_token(token, token_path)

    os.environ['OAUTHLIB_RELAX_TOKEN_SCOPE'] = 'True'
    client = OAuth2Session(
        client_id,
        scope=MS_SCOPES,
        redirect_uri=redirect_uri,
        token=token,
        auto_refresh_url=token_url,
        # auto_refresh_kwargs=extra,
        token_updater=token_updater,
    )

    logger.debug(f"client authorized (expected): {client.authorized}")

    logger.debug("refreshing token...")
    try:
        # FIXME: this doesn't seem to be updating the cached token?
        # FIXME: do we need to manually write the token?
        token = client.refresh_token(token_url)#, **extra)
        expired = log_token(token)
        return token
    # FIXME: should we not capture just this specific exception?
    #except oauthlib.oauth2.rfc6749.errors.InvalidGrantError as e:
    except Exception as e:
        #logger.exception(e)
        logger.error(e)

    logger.debug("retrieving new token...")

    authorization_url, state = client.authorization_url(auth_url)
    logger.debug(f"state: {state}")
    logger.debug(f"authorization url: {authorization_url}")

    if use_localhost:
        authorization_redirect = user_resolve_auth_url_localhost(authorization_url)
    else:
        authorization_redirect = user_resolve_auth_url_manual(authorization_url)
    logger.debug(f"redirect url: {authorization_redirect}")

    logger.debug("token fetch...")
    token = client.fetch_token(
        token_url,
        authorization_response=authorization_redirect,
        include_client_id=True,
    )
    acquired = time.time()
    expires = datetime.fromtimestamp(token['expires_at'])
    logger.debug(f"new token retrieved (expires: {expires})")

    write_token(token, token_path, acquired=acquired)

    return token

##################################################

parser = argparse.ArgumentParser(
    description="retrieve, manage, and return MS xoauth2 access token",
    formatter_class=argparse.ArgumentDefaultsHelpFormatter,
)
parser.add_argument(
    '--config', '-c', default=DEFAULT_CONFIG_PATH,
    help="path to config file tenant and client_id strings",
)
parser.add_argument(
    '--account', '-a', default='default',
    help="config account to use",
)
parser.add_argument(
    '--manual', action='store_true',
    help="use manual URL paste method instead of localhost callback",
)
parser.add_argument(
    '--port', '-p', type=int, default=LOCALHOST_PORT,
    help="port for localhost OAuth callback server",
)


def main():
    logger.setLevel(os.getenv('LOG_LEVEL', 'DEBUG').upper())
    handler = logging.StreamHandler()
    handler.setFormatter(
        logging.Formatter(
            # '%(asctime)s %(message)s'
            '%(message)s'
        )
    )
    logger.addHandler(handler)

    args = parser.parse_args()

    # Update port if specified
    global LOCALHOST_PORT
    LOCALHOST_PORT = args.port

    config = load_config(args.config)

    account = get_account(config, args.account)

    token = get_token(account, use_localhost=not args.manual)

    print(token['access_token'])


if __name__ == '__main__':
    main()
